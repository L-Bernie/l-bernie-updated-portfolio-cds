import _decorate from "@babel/runtime/helpers/esm/decorate";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _get from "@babel/runtime/helpers/esm/get";
let _ = t => t,
  _t,
  _t2,
  _t3,
  _t4,
  _t5,
  _t6,
  _t7,
  _t8,
  _t9,
  _t10,
  _t11;
function _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }
/**
 * @license
 *
 * Copyright IBM Corp. 2023, 2024
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { LitElement, html } from 'lit';
import { property, query, queryAssignedElements, state } from 'lit/decorators.js';
import { prefix } from '../../globals/settings';
import HostListener from '../../globals/decorators/host-listener';
import HostListenerMixin from '../../globals/mixins/host-listener';
import { SIDE_PANEL_SIZE, SIDE_PANEL_PLACEMENT } from './defs';
import styles from "././side-panel.css.js";
import { selectorTabbable } from '../../globals/settings';
import { carbonElement as customElement } from '../../globals/decorators/carbon-element';
import ArrowLeft16 from "../../icons/arrow--left/16";
import Close20 from "../../icons/close/20";
import { moderate02 } from '@carbon/motion';
import '../button/index';
import '../icon-button/index';
import '../layer/index';
import '../button/button-set-base';
export { SIDE_PANEL_SIZE, SIDE_PANEL_PLACEMENT };

// eslint-disable-next-line no-bitwise
const PRECEDING = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;
// eslint-disable-next-line no-bitwise
const FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY;
const blockClass = `${prefix}--side-panel`;
const blockClassActionSet = `${prefix}--action-set`;

/**
 * Observes resize of the given element with the given resize observer.
 *
 * @param observer The resize observer.
 * @param elem The element to observe the resize.
 */
const observeResize = (observer, elem) => {
  if (!elem) {
    return null;
  }
  observer.observe(elem);
  return {
    release() {
      observer.unobserve(elem);
      return null;
    }
  };
};

/**
 * Tries to focus on the given elements and bails out if one of them is successful.
 *
 * @param elems The elements.
 * @param reverse `true` to go through the list in reverse order.
 * @returns `true` if one of the attempts is successful, `false` otherwise.
 */
function tryFocusElems(elems, reverse) {
  if (!reverse) {
    for (let i = 0; i < elems.length; ++i) {
      const elem = elems[i];
      elem.focus();
      if (elem.ownerDocument.activeElement === elem) {
        return true;
      }
    }
  } else {
    for (let i = elems.length - 1; i >= 0; --i) {
      const elem = elems[i];
      elem.focus();
      if (elem.ownerDocument.activeElement === elem) {
        return true;
      }
    }
  }
  return false;
}

/**
 * SidePanel.
 *
 * @element cds-side-panel
 * @csspart dialog The dialog.
 * @fires cds-side-panel-beingclosed
 *   The custom event fired before this side-panel is being closed upon a user gesture.
 *   Cancellation of this event stops the user-initiated action of closing this side-panel.
 * @fires cds-side-panel-closed - The custom event fired after this side-panel is closed upon a user gesture.
 * @fires cds-side-panel-navigate-back - custom event fired when clicking navigate back (available when step > 0)
 */
let CDSSidePanel = _decorate([customElement(`${prefix}-side-panel`)], function (_initialize, _HostListenerMixin) {
  class CDSSidePanel extends _HostListenerMixin {
    constructor(...args) {
      super(...args);
      _initialize(this);
    }
  }
  return {
    F: CDSSidePanel,
    d: [{
      kind: "field",
      key: "_hObserveResize",
      value() {
        return null;
      }
    }, {
      kind: "field",
      key: "_launcher",
      value() {
        return null;
      }
    }, {
      kind: "field",
      decorators: [query('#start-sentinel')],
      key: "_startSentinelNode",
      value: void 0
    }, {
      kind: "field",
      decorators: [query('#end-sentinel')],
      key: "_endSentinelNode",
      value: void 0
    }, {
      kind: "field",
      decorators: [query(`.${blockClass}`)],
      key: "_sidePanel",
      value: void 0
    }, {
      kind: "field",
      decorators: [query(`.${blockClass}__animated-scroll-wrapper`)],
      key: "_animateScrollWrapper",
      value: void 0
    }, {
      kind: "field",
      decorators: [query(`.${blockClass}__label-text`)],
      key: "_label",
      value: void 0
    }, {
      kind: "field",
      decorators: [query(`.${blockClass}__title-text`)],
      key: "_title",
      value: void 0
    }, {
      kind: "field",
      decorators: [query(`.${blockClass}__subtitle-text`)],
      key: "_subtitle",
      value: void 0
    }, {
      kind: "field",
      decorators: [query(`.${blockClass}__inner-content`)],
      key: "_innerContent",
      value: void 0
    }, {
      kind: "field",
      decorators: [queryAssignedElements({
        slot: 'actions',
        selector: `${prefix}-button`
      })],
      key: "_actions",
      value: void 0
    }, {
      kind: "field",
      decorators: [state()],
      key: "_doAnimateTitle",
      value() {
        return true;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_isOpen",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_containerScrollTop",
      value() {
        return -16;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_hasSubtitle",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_hasSlug",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_hasActionToolbar",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_actionsCount",
      value() {
        return 0;
      }
    }, {
      kind: "field",
      decorators: [state()],
      key: "_slugCloseSize",
      value() {
        return 'sm';
      }
    }, {
      kind: "field",
      decorators: [HostListener('shadowRoot:focusout')],
      key: "_handleBlur",
      value() {
        return async ({
          target,
          relatedTarget
        }) => {
          var _this$shadowRoot;
          const {
            open,
            _startSentinelNode: startSentinelNode,
            _endSentinelNode: endSentinelNode
          } = this;
          const oldContains = target !== this && this.contains(target);
          const currentContains = relatedTarget !== this && (this.contains(relatedTarget) || ((_this$shadowRoot = this.shadowRoot) === null || _this$shadowRoot === void 0 ? void 0 : _this$shadowRoot.contains(relatedTarget)) && relatedTarget !== startSentinelNode && relatedTarget !== endSentinelNode);

          // Performs focus wrapping if _all_ of the following is met:
          // * This side-panel is open
          // * The viewport still has focus
          // * SidePanel body used to have focus but no longer has focus
          const {
            selectorTabbable: selectorTabbableForSidePanel
          } = this.constructor;
          if (open && relatedTarget && oldContains && !currentContains) {
            const comparisonResult = target.compareDocumentPosition(relatedTarget);
            // eslint-disable-next-line no-bitwise
            if (relatedTarget === startSentinelNode || comparisonResult & PRECEDING) {
              await this.constructor._delay();
              if (!tryFocusElems(this.querySelectorAll(selectorTabbableForSidePanel), true) && relatedTarget !== this) {
                this.focus();
              }
            }
            // eslint-disable-next-line no-bitwise
            else if (relatedTarget === endSentinelNode || comparisonResult & FOLLOWING) {
              await this.constructor._delay();
              if (!tryFocusElems(this.querySelectorAll(selectorTabbableForSidePanel), true)) {
                this.focus();
              }
            }
          }
        };
      }
    }, {
      kind: "field",
      decorators: [HostListener('document:keydown')],
      key: "_handleKeydown",
      value() {
        return ({
          key,
          target
        }) => {
          if (key === 'Esc' || key === 'Escape') {
            this._handleUserInitiatedClose(target);
          }
        };
      }
    }, {
      kind: "field",
      key: "_reducedMotion",
      value() {
        var _window;
        return typeof window !== 'undefined' && (_window = window) !== null && _window !== void 0 && _window.matchMedia ? window.matchMedia('(prefers-reduced-motion: reduce)') : {
          matches: true
        };
      }
    }, {
      kind: "method",
      key: "_handleClickOnOverlay",
      value:
      /**
       * The handle for observing resize of the parent element of this element.
       */

      /**
       * The element that had focus before this side-panel gets open.
       */

      /**
       * Node to track focus going outside of side-panel content.
       */

      /**
       * Node to track focus going outside of side-panel content.
       */

      /**
       * Node to track side panel.
       */

      /**
       * Handles `blur` event on this element.
       *
       * @param event The event.
       * @param event.target The event target.
       * @param event.relatedTarget The event relatedTarget.
       */

      /**
       * Handles `click` event on the side-panel container.
       *
       * @param event The event.
       */
      function _handleClickOnOverlay(event) {
        if (!this.preventCloseOnClickOutside) {
          this._handleUserInitiatedClose(event.target);
        }
      }

      /**
       * Handles `click` event on the side-panel container.
       *
       * @param event The event.
       */
    }, {
      kind: "method",
      key: "_handleCloseClick",
      value: function _handleCloseClick(event) {
        this._handleUserInitiatedClose(event.target);
      }

      /**
       * Handles user-initiated close request of this side-panel.
       *
       * @param triggeredBy The element that triggered this close request.
       */
    }, {
      kind: "method",
      key: "_handleUserInitiatedClose",
      value: function _handleUserInitiatedClose(triggeredBy) {
        if (this.open) {
          const init = {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              triggeredBy
            }
          };
          if (this.dispatchEvent(new CustomEvent(this.constructor.eventBeforeClose, init))) {
            this.open = false;
            this.dispatchEvent(new CustomEvent(this.constructor.eventClose, init));
          }
        }
      }
    }, {
      kind: "method",
      key: "_handleNavigateBack",
      value: function _handleNavigateBack(triggeredBy) {
        this.dispatchEvent(new CustomEvent(this.constructor.eventNavigateBack, {
          composed: true,
          detail: {
            triggeredBy
          }
        }));
      }
    }, {
      kind: "field",
      key: "_adjustPageContent",
      value() {
        return () => {
          // sets/resets styles based on slideIn property and selectorPageContent;
          if (this.selectorPageContent) {
            const pageContentEl = document.querySelector(this.selectorPageContent);
            if (pageContentEl) {
              const newValues = {
                marginInlineStart: '',
                marginInlineEnd: '',
                inlineSize: '',
                transition: this._reducedMotion.matches ? 'none' : `all ${moderate02}`,
                transitionProperty: 'margin-inline-start, margin-inline-end'
              };
              if (this.open) {
                newValues.inlineSize = 'auto';
                if (this.placement === 'left') {
                  var _this$_sidePanel;
                  newValues.marginInlineStart = `${this === null || this === void 0 || (_this$_sidePanel = this._sidePanel) === null || _this$_sidePanel === void 0 ? void 0 : _this$_sidePanel.offsetWidth}px`;
                } else {
                  var _this$_sidePanel2;
                  newValues.marginInlineEnd = `${this === null || this === void 0 || (_this$_sidePanel2 = this._sidePanel) === null || _this$_sidePanel2 === void 0 ? void 0 : _this$_sidePanel2.offsetWidth}px`;
                }
              }
              Object.keys(newValues).forEach(key => {
                pageContentEl.style[key] = newValues[key];
              });
            }
          }
        };
      }
    }, {
      kind: "field",
      key: "_checkSetOpen",
      value() {
        return () => {
          const {
            _sidePanel: sidePanel
          } = this;
          if (sidePanel && this._isOpen) {
            if (this._reducedMotion) {
              this._isOpen = false;
            } else {
              // wait until the side panel has transitioned off the screen to remove
              sidePanel.addEventListener('transitionend', () => {
                this._isOpen = false;
              });
            }
          } else {
            // allow the html to render before animating in the side panel
            this._isOpen = this.open;
          }
        };
      }
    }, {
      kind: "field",
      key: "_checkUpdateIconButtonSizes",
      value() {
        return () => {
          var _this$shadowRoot2;
          const slug = this.querySelector(`${prefix}-slug`);
          const otherButtons = this === null || this === void 0 || (_this$shadowRoot2 = this.shadowRoot) === null || _this$shadowRoot2 === void 0 ? void 0 : _this$shadowRoot2.querySelectorAll('#nav-back-button, #close-button');
          let iconButtonSize = 'sm';
          if (slug || otherButtons !== null && otherButtons !== void 0 && otherButtons.length) {
            var _this$querySelectorAl;
            const actions = this === null || this === void 0 || (_this$querySelectorAl = this.querySelectorAll) === null || _this$querySelectorAl === void 0 ? void 0 : _this$querySelectorAl.call(this, `${prefix}-button[slot='actions']`);
            if (actions !== null && actions !== void 0 && actions.length && /l/.test(this.size)) {
              iconButtonSize = 'md';
            }
          }
          if (slug) {
            slug === null || slug === void 0 || slug.setAttribute('size', iconButtonSize);
          }
          if (otherButtons) {
            [...otherButtons].forEach(btn => {
              btn.setAttribute('size', iconButtonSize);
            });
          }
        };
      }
    }, {
      kind: "method",
      key: "_handleSlugChange",
      value: function _handleSlugChange(e) {
        this._checkUpdateIconButtonSizes();
        const childItems = e.target.assignedElements();
        this._hasSlug = childItems.length > 0;
      }
    }, {
      kind: "method",
      key: "_handleSubtitleChange",
      value: function _handleSubtitleChange(e) {
        const target = e.target;
        const subtitle = target === null || target === void 0 ? void 0 : target.assignedElements();
        this._hasSubtitle = subtitle.length > 0;
      }

      // eslint-disable-next-line class-methods-use-this
    }, {
      kind: "method",
      key: "_handleActionToolbarChange",
      value: function _handleActionToolbarChange(e) {
        const target = e.target;
        const toolbarActions = target === null || target === void 0 ? void 0 : target.assignedElements();
        this._hasActionToolbar = toolbarActions && toolbarActions.length > 0;
        if (this._hasActionToolbar) {
          for (const toolbarAction of toolbarActions) {
            // toolbar actions size should always be sm
            toolbarAction.setAttribute('size', 'sm');
          }
        }
      }
    }, {
      kind: "field",
      key: "_checkUpdateActionSizes",
      value() {
        return () => {
          if (this._actions) {
            for (let i = 0; i < this._actions.length; i++) {
              this._actions[i].setAttribute('size', this.condensedActions ? 'lg' : 'xl');
            }
          }
        };
      }
    }, {
      kind: "field",
      key: "_maxActions",
      value() {
        return 3;
      }
    }, {
      kind: "method",
      key: "_handleActionsChange",
      value: function _handleActionsChange(e) {
        var _actions$length;
        const target = e.target;
        const actions = target === null || target === void 0 ? void 0 : target.assignedElements();

        // update slug size
        this._checkUpdateIconButtonSizes();
        const actionsCount = (_actions$length = actions === null || actions === void 0 ? void 0 : actions.length) !== null && _actions$length !== void 0 ? _actions$length : 0;
        if (actionsCount > this._maxActions) {
          this._actionsCount = this._maxActions;
          if (process.env.NODE_ENV === 'development') {
            console.error(`Too many side-panel actions, max ${this._maxActions}.`);
          }
        } else {
          this._actionsCount = actionsCount;
        }
        for (let i = 0; i < (actions === null || actions === void 0 ? void 0 : actions.length); i++) {
          if (i + 1 > this._maxActions) {
            // hide excessive side panel actions
            actions[i].setAttribute('hidden', 'true');
            actions[i].setAttribute(`data-actions-limit-${this._maxActions}-exceeded`, `${actions.length}`);
          } else {
            actions[i].classList.add(`${blockClassActionSet}__action-button`);
          }
        }
        this._checkUpdateActionSizes();
      }
    }, {
      kind: "field",
      key: "_checkSetDoAnimateTitle",
      value() {
        return () => {
          var _this$title;
          let canDoAnimateTitle = false;
          if (this._sidePanel && this.open && this.animateTitle && this !== null && this !== void 0 && (_this$title = this.title) !== null && _this$title !== void 0 && _this$title.length && !this._reducedMotion.matches) {
            var _this$_sidePanel3;
            const scrollAnimationDistance = this._getScrollAnimationDistance();
            // used to calculate the header moves
            this === null || this === void 0 || (_this$_sidePanel3 = this._sidePanel) === null || _this$_sidePanel3 === void 0 || (_this$_sidePanel3 = _this$_sidePanel3.style) === null || _this$_sidePanel3 === void 0 || _this$_sidePanel3.setProperty(`--${blockClass}--scroll-animation-distance`, `${scrollAnimationDistance}`);
            let scrollEl = this._animateScrollWrapper;
            if (!scrollEl && this.animateTitle && !this._doAnimateTitle) {
              scrollEl = this._innerContent;
            }
            if (scrollEl) {
              var _window2;
              const innerComputed = (_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.getComputedStyle(this._innerContent);
              const innerPaddingHeight = innerComputed ? parseFloat(innerComputed === null || innerComputed === void 0 ? void 0 : innerComputed.paddingTop) + parseFloat(innerComputed === null || innerComputed === void 0 ? void 0 : innerComputed.paddingBottom) : 0;
              canDoAnimateTitle = (!!this.labelText || !!this._hasActionToolbar || this._hasSubtitle) && scrollEl.scrollHeight - scrollEl.clientHeight >= scrollAnimationDistance + innerPaddingHeight;
            }
          }
          this._doAnimateTitle = canDoAnimateTitle;
        };
      }
    }, {
      kind: "field",
      key: "_resizeObserver",
      value() {
        return new ResizeObserver(() => {
          if (this._sidePanel) {
            this._checkSetDoAnimateTitle();
          }
        });
      }
    }, {
      kind: "field",
      key: "_getScrollAnimationDistance",
      value() {
        return () => {
          var _this$_label$offsetHe, _this$_label, _this$_subtitle$offse, _this$_subtitle;
          const labelHeight = (_this$_label$offsetHe = this === null || this === void 0 || (_this$_label = this._label) === null || _this$_label === void 0 ? void 0 : _this$_label.offsetHeight) !== null && _this$_label$offsetHe !== void 0 ? _this$_label$offsetHe : 0;
          const subtitleHeight = (_this$_subtitle$offse = this === null || this === void 0 || (_this$_subtitle = this._subtitle) === null || _this$_subtitle === void 0 ? void 0 : _this$_subtitle.offsetHeight) !== null && _this$_subtitle$offse !== void 0 ? _this$_subtitle$offse : 0;
          const titleVerticalBorder = this._hasActionToolbar ? this._title.offsetHeight - this._title.clientHeight : 0;
          return labelHeight + subtitleHeight + titleVerticalBorder;
        };
      }
    }, {
      kind: "field",
      key: "_scrollObserver",
      value() {
        return () => {
          var _this$_animateScrollW, _this$_animateScrollW2, _this$_sidePanel4;
          const scrollTop = (_this$_animateScrollW = (_this$_animateScrollW2 = this._animateScrollWrapper) === null || _this$_animateScrollW2 === void 0 ? void 0 : _this$_animateScrollW2.scrollTop) !== null && _this$_animateScrollW !== void 0 ? _this$_animateScrollW : 0;
          const scrollAnimationDistance = this._getScrollAnimationDistance();
          this === null || this === void 0 || (_this$_sidePanel4 = this._sidePanel) === null || _this$_sidePanel4 === void 0 || (_this$_sidePanel4 = _this$_sidePanel4.style) === null || _this$_sidePanel4 === void 0 || _this$_sidePanel4.setProperty(`--${blockClass}--scroll-animation-progress`, `${Math.min(scrollTop, scrollAnimationDistance) / scrollAnimationDistance}`);
        };
      }
    }, {
      kind: "field",
      key: "_handleCurrentStepUpdate",
      value() {
        return () => {
          var _this$_animateScrollW3;
          const scrollable = (_this$_animateScrollW3 = this._animateScrollWrapper) !== null && _this$_animateScrollW3 !== void 0 ? _this$_animateScrollW3 : this._innerContent;
          if (scrollable) {
            scrollable.scrollTop = 0;
          }
        };
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'animate-title',
        type: Boolean
      })],
      key: "animateTitle",
      value() {
        return true;
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'close-icon-description'
      })],
      key: "closeIconDescription",
      value() {
        return 'Close';
      }
    }, {
      kind: "field",
      decorators: [property({
        type: Boolean,
        reflect: true,
        attribute: 'condensed-actions'
      })],
      key: "condensedActions",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'current-step',
        type: Number
      })],
      key: "currentStep",
      value: void 0
    }, {
      kind: "field",
      decorators: [property({
        attribute: 'include-overlay',
        type: Boolean,
        reflect: true
      })],
      key: "includeOverlay",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'label-text'
      })],
      key: "labelText",
      value: void 0
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'navigation-back-icon-description'
      })],
      key: "navigationBackIconDescription",
      value() {
        return 'Back';
      }
    }, {
      kind: "field",
      decorators: [property({
        type: Boolean,
        reflect: true
      })],
      key: "open",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        type: String
      })],
      key: "placement",
      value() {
        return SIDE_PANEL_PLACEMENT.RIGHT;
      }
    }, {
      kind: "field",
      decorators: [property({
        type: Boolean,
        attribute: 'prevent-close-on-click-outside'
      })],
      key: "preventCloseOnClickOutside",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'selector-initial-focus',
        type: String
      })],
      key: "selectorInitialFocus",
      value: void 0
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        attribute: 'selector-page-content'
      })],
      key: "selectorPageContent",
      value() {
        return '';
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: true,
        type: String
      })],
      key: "size",
      value() {
        return SIDE_PANEL_SIZE.MEDIUM;
      }
    }, {
      kind: "field",
      decorators: [property({
        attribute: 'slide-in',
        type: Boolean,
        reflect: true
      })],
      key: "slideIn",
      value() {
        return false;
      }
    }, {
      kind: "field",
      decorators: [property({
        reflect: false,
        type: String
      })],
      key: "title",
      value: void 0
    }, {
      kind: "method",
      key: "connectObservers",
      value:
      /**
       * The `ResizeObserver` instance for observing element resizes for re-positioning floating menu position.
       */
      // TODO: Wait for `.d.ts` update to support `ResizeObserver`
      // @ts-ignore
      /**
       * Determines if the title will animate on scroll
       */
      /**
       * Sets the close button icon description
       */
      /**
       * Determines whether the side panel should render the condensed version (affects action buttons primarily)
       */
      /**
       * Sets the current step of the side panel
       */
      /**
       * Determines whether the side panel should render with an overlay
       */
      /**
       * Sets the label text which will display above the title text
       */
      /**
       * Sets the icon description for the navigation back icon button
       */
      /**
       * `true` if the side-panel should be open.
       */
      /**
       * SidePanel placement.
       */
      /**
       * Prevent closing on click outside of side-panel
       */
      /**
       * The initial location of focus in the side panel
       */
      /**
       * Selector for page content, used to push content to side except
       */
      /**
       * SidePanel size.
       */
      /**
       * Determines if this panel slides in
       */
      /**
       * Sets the title text
       */
      async function connectObservers() {
        await this.updateComplete;
        this._hObserveResize = observeResize(this._resizeObserver, this._sidePanel);
      }
    }, {
      kind: "method",
      key: "disconnectObservers",
      value: function disconnectObservers() {
        if (this._hObserveResize) {
          this._hObserveResize = this._hObserveResize.release();
        }
      }
    }, {
      kind: "method",
      key: "connectedCallback",
      value: function connectedCallback() {
        _superPropGet(CDSSidePanel, "connectedCallback", this, 3)([]);
        this.disconnectObservers();
        this.connectObservers();
      }
    }, {
      kind: "method",
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _superPropGet(CDSSidePanel, "disconnectedCallback", this, 3)([]);
        this.disconnectObservers();
      }
    }, {
      kind: "method",
      key: "render",
      value: function render() {
        const {
          closeIconDescription,
          condensedActions,
          currentStep,
          includeOverlay,
          labelText,
          navigationBackIconDescription,
          open,
          placement,
          size,
          slideIn,
          title
        } = this;
        if (!open && !this._isOpen) {
          return html(_t || (_t = _``));
        }
        const actionsMultiple = ['', 'single', 'double', 'triple'][this._actionsCount];
        const titleTemplate = html(_t2 || (_t2 = _`<div
      class=${0}
      ?no-label=${0}>
      <h2 class=${0} title=${0}>
        ${0}
      </h2>

      ${0}
    </div>`), `${blockClass}__title`, !!labelText, title ? `${blockClass}__title-text` : '', title, title, this._doAnimateTitle ? html(_t3 || (_t3 = _`<h2
            class=${0}
            title=${0}
            aria-hidden="true">
            ${0}
          </h2>`), `${blockClass}__collapsed-title-text`, title, title) : '');
        const headerHasTitleClass = this.title ? ` ${blockClass}__header--has-title ` : '';
        const headerTemplate = html(_t4 || (_t4 = _`
      <div
        class=${0}
        ?detail-step=${0}
        ?no-title-animation=${0}
        ?reduced-motion=${0}>
        <!-- render back button -->
        ${0}

        <!-- render title label -->
        ${0}

        <!-- title -->
        ${0}

        <!-- render slug and close button area -->
        <div class=${0}>
          <slot name="slug" @slotchange=${0}></slot>
          <!-- {normalizedSlug} -->
          <cds-icon-button
            align="bottom-right"
            aria-label=${0}
            kind="ghost"
            size="sm"
            class=${0}
            @click=${0}>
            ${0}
            <span slot="tooltip-content"> ${0} </span>
          </cds-icon-button>
        </div>

        <!-- render sub title -->
        <p
          class=${0}
          ?hidden=${0}
          ?no-title-animation=${0}
          ?no-action-toolbar=${0}
          ?no-title=${0}>
          <slot
            name="subtitle"
            @slotchange=${0}></slot>
        </p>

        <div
          class=${0}
          ?hidden=${0}
          ?no-title-animation=${0}>
          <slot
            name="action-toolbar"
            @slotchange=${0}></slot>
        </div>
      </div>
    `), `${blockClass}__header${headerHasTitleClass}`, currentStep > 0, !this._doAnimateTitle, this._reducedMotion.matches, currentStep > 0 ? html(_t5 || (_t5 = _`<cds-icon-button
              align="bottom-left"
              aria-label=${0}
              kind="ghost"
              size="sm"
              class=${0}
              @click=${0}>
              ${0}
              <span slot="tooltip-content">
                ${0}
              </span>
            </cds-icon-button>`), navigationBackIconDescription, `${prefix}--btn ${blockClass}__navigation-back-button`, this._handleNavigateBack, ArrowLeft16({
          slot: 'icon'
        }), navigationBackIconDescription) : '', title !== null && title !== void 0 && title.length && labelText !== null && labelText !== void 0 && labelText.length ? html(_t6 || (_t6 = _` <p class=${0}>${0}</p>`), `${blockClass}__label-text`, labelText) : '', title ? titleTemplate : '', `${blockClass}__slug-and-close`, this._handleSlugChange, closeIconDescription, `${blockClass}__close-button`, this._handleCloseClick, Close20({
          slot: 'icon'
        }), closeIconDescription, this._hasSubtitle ? `${blockClass}__subtitle-text` : '', !this._hasSubtitle, !this._doAnimateTitle, !this._hasActionToolbar, !title, this._handleSubtitleChange, this._hasActionToolbar ? `${blockClass}__action-toolbar` : '', !this._hasActionToolbar, !this._doAnimateTitle, this._handleActionToolbarChange);
        const mainTemplate = html(_t7 || (_t7 = _`<div
      class=${0}
      ?scrolls=${0}>
      <cds-layer level="1">
        <slot></slot>
      </cds-layer>
    </div> `), `${blockClass}__inner-content`, !this._doAnimateTitle);
        const sidePanelAnimateTitleClass = this._doAnimateTitle ? ` ${blockClass}--animated-title` : '';
        return html(_t8 || (_t8 = _`
      <div
        class=${0}
        part="dialog"
        role="complementary"
        placement="${0}"
        ?has-slug=${0}
        ?open=${0}
        ?opening=${0}
        ?closing=${0}
        ?condensed-actions=${0}
        ?overlay=${0}
        ?slide-in=${0}
        size=${0}>
        <a
          id="start-sentinel"
          class="sentinel"
          hidden
          href="javascript:void 0"
          role="navigation"></a>

        ${0}

        <cds-button-set-base
          class=${0}
          ?hidden=${0}
          ?condensed=${0}
          actions-multiple=${0}
          size=${0}>
          <slot name="actions" @slotchange=${0}></slot>
        </cds-button-set-base>

        <a
          id="end-sentinel"
          class="sentinel"
          hidden
          href="javascript:void 0"
          role="navigation"></a>
      </div>

      ${0}
    `), `${blockClass}${sidePanelAnimateTitleClass}`, placement, this._hasSlug, this._isOpen, open && !this._isOpen, !open && this._isOpen, condensedActions, includeOverlay || slideIn, slideIn, size, this._doAnimateTitle ? html(_t9 || (_t9 = _`<div class=${0} scrolls>
              ${0} ${0}
            </div>`), `${blockClass}__animated-scroll-wrapper`, headerTemplate, mainTemplate) : html(_t10 || (_t10 = _` ${0} ${0}`), headerTemplate, mainTemplate), `${blockClass}__actions-container`, this._actionsCount === 0, condensedActions, actionsMultiple, size, this._handleActionsChange, includeOverlay ? html(_t11 || (_t11 = _`<div
            ?slide-in=${0}
            class=${0}
            ?open=${0}
            ?opening=${0}
            ?closing=${0}
            tabindex="-1"
            @click=${0}></div>`), slideIn, `${blockClass}__overlay`, this.open, open && !this._isOpen, !open && this._isOpen, this._handleClickOnOverlay) : '');
      }
    }, {
      kind: "method",
      key: "updated",
      value: async function updated(changedProperties) {
        if (changedProperties.has('condensedActions')) {
          this._checkUpdateActionSizes();
        }
        if (changedProperties.has('currentStep')) {
          this._handleCurrentStepUpdate();
        }
        if (changedProperties.has('_doAnimateTitle')) {
          var _this$_animateScrollW4;
          this === null || this === void 0 || (_this$_animateScrollW4 = this._animateScrollWrapper) === null || _this$_animateScrollW4 === void 0 || _this$_animateScrollW4.removeEventListener('scroll', this._scrollObserver);
          if (this._doAnimateTitle) {
            var _this$_animateScrollW5;
            this === null || this === void 0 || (_this$_animateScrollW5 = this._animateScrollWrapper) === null || _this$_animateScrollW5 === void 0 || _this$_animateScrollW5.addEventListener('scroll', this._scrollObserver);
          } else {
            var _this$_sidePanel5;
            this === null || this === void 0 || (_this$_sidePanel5 = this._sidePanel) === null || _this$_sidePanel5 === void 0 || (_this$_sidePanel5 = _this$_sidePanel5.style) === null || _this$_sidePanel5 === void 0 || _this$_sidePanel5.setProperty(`--${blockClass}--scroll-animation-progress`, '0');
          }
        }
        if (changedProperties.has('_isOpen') || changedProperties.has('animateTitle')) {
          /* @state property changed */
          this._checkSetDoAnimateTitle();
        }
        if (changedProperties.has('slideIn') || changedProperties.has('open') || changedProperties.has('includeOverlay')) {
          this._adjustPageContent();
        }
        if (changedProperties.has('open')) {
          this._checkSetOpen();
          this.disconnectObservers();
          if (this.open) {
            this.connectObservers();
            this._launcher = this.ownerDocument.activeElement;
            const focusNode = this.selectorInitialFocus && this.querySelector(this.selectorInitialFocus);
            await this.constructor._delay();
            if (focusNode) {
              // For cases where a `carbon-web-components` component (e.g. `<cds-button>`) being `primaryFocusNode`,
              // where its first update/render cycle that makes it focusable happens after `<cds-side-panel>`'s first update/render cycle
              focusNode.focus();
            } else if (!tryFocusElems(this.querySelectorAll(this.constructor.selectorTabbable), true)) {
              this.focus();
            }
          } else if (this._launcher && typeof this._launcher.focus === 'function') {
            this._launcher.focus();
            this._launcher = null;
          }
        }
      }

      /**
       * @param ms The number of milliseconds.
       * @returns A promise that is resolves after the given milliseconds.
       */
    }, {
      kind: "method",
      static: true,
      key: "_delay",
      value: function _delay(ms = 0) {
        return new Promise(resolve => {
          setTimeout(resolve, ms);
        });
      }

      /**
       * A selector selecting tabbable nodes.
       */
    }, {
      kind: "get",
      static: true,
      key: "selectorTabbable",
      value: function () {
        return selectorTabbable;
      }

      /**
       * The name of the custom event fired before this side-panel is being closed upon a user gesture.
       * Cancellation of this event stops the user-initiated action of closing this side-panel.
       */
    }, {
      kind: "get",
      static: true,
      key: "eventBeforeClose",
      value: function () {
        return `${prefix}-side-panel-beingclosed`;
      }

      /**
       * The name of the custom event fired after this side-panel is closed upon a user gesture.
       */
    }, {
      kind: "get",
      static: true,
      key: "eventClose",
      value: function () {
        return `${prefix}-side-panel-closed`;
      }

      /**
       * The name of the custom event fired on clicking the navigate back button
       */
    }, {
      kind: "get",
      static: true,
      key: "eventNavigateBack",
      value: function () {
        return `${prefix}-side-panel-navigate-back`;
      }
    }, {
      kind: "field",
      static: true,
      key: "styles",
      value() {
        return styles;
      }
    }]
  };
}, HostListenerMixin(LitElement));
export default CDSSidePanel;
//# sourceMappingURL=side-panel.js.map
