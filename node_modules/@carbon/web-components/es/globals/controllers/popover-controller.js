import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
/**
 * @license
 *
 * Copyright IBM Corp. 2024
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { computePosition, flip, offset, arrow, autoUpdate } from '@floating-ui/dom';
export default class PopoverController {
  /**
   * Host component
   */

  /**
   * Floating-ui options to pass to `computePlacement()`
   */

  /**
   * cleanup function to stop auto updates
   */

  /**
   * register with host component
   * @param host host component
   */
  constructor(host) {
    _defineProperty(this, "updatePlacement", () => {
      this.computePlacement();
    });
    (this.host = host).addController(this);
  }
  async setPlacement(options = this.options) {
    this.options = options;
    const {
      trigger,
      target
    } = options;
    this.cleanup = autoUpdate(trigger, target, this.updatePlacement);
  }
  async computePlacement() {
    const {
      arrowElement,
      alignment,
      caret,
      trigger,
      target
    } = this.options;
    let shimmedAlign;
    switch (alignment) {
      case 'top-left':
        shimmedAlign = 'top-start';
        break;
      case 'top-right':
        shimmedAlign = 'top-end';
        break;
      case 'bottom-left':
        shimmedAlign = 'bottom-start';
        break;
      case 'bottom-right':
        shimmedAlign = 'bottom-end';
        break;
      case 'left-bottom':
        shimmedAlign = 'left-end';
        break;
      case 'left-top':
        shimmedAlign = 'left-start';
        break;
      case 'right-bottom':
        shimmedAlign = 'right-end';
        break;
      case 'right-top':
        shimmedAlign = 'right-start';
        break;
      default:
        shimmedAlign = alignment;
        break;
    }
    const middleware = [flip({
      fallbackAxisSideDirection: 'start'
    }), offset(caret ? 10 : 0), ...(caret && arrowElement ? [arrow({
      element: arrowElement,
      padding: 15
    })] : [])];
    if (this.host.hasAttribute('open')) {
      const {
        x,
        y,
        placement,
        middlewareData,
        strategy
      } = await computePosition(trigger, target, {
        strategy: 'fixed',
        middleware,
        placement: shimmedAlign
      });
      target.style.left = `${x}px`;
      target.style.top = `${y}px`;
      target.style.position = `${strategy}`;
      if (arrowElement) {
        // @ts-ignore
        const {
          x: arrowX,
          y: arrowY
        } = middlewareData.arrow;
        const staticSide = {
          top: 'bottom',
          right: 'left',
          bottom: 'top',
          left: 'right'
        }[placement.split('-')[0]];
        arrowElement.style.left = arrowX != null ? `${arrowX}px` : '';
        arrowElement.style.top = arrowY != null ? `${arrowY}px` : '';
        arrowElement.style.right = '';
        arrowElement.style.bottom = '';
        arrowElement.style[staticSide] = `${-arrowElement.offsetWidth / 2}px`;
      }

      // adding specific case here where the style of the caret/arrow
      // is dependent on the placement
      if (this.host.tagName === 'CDS-SLUG') {
        var _this$host;
        (_this$host = this.host) === null || _this$host === void 0 || _this$host.setAttribute('alignment', placement);
      }
    }
  }
  hostUpdated() {
    if (!this.host.hasAttribute('open')) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) === null || _this$cleanup === void 0 || _this$cleanup.call(this);
      this.cleanup = undefined;
    }
  }
  hostDisconnected() {
    var _this$cleanup2;
    (_this$cleanup2 = this.cleanup) === null || _this$cleanup2 === void 0 || _this$cleanup2.call(this);
    this.cleanup = undefined;
  }
}
//# sourceMappingURL=popover-controller.js.map
